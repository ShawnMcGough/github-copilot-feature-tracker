<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>GitHub Copilot Feature Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="assets/styles.css" />
</head>

<body>
    <header>
        <h1>GitHub Copilot Feature Tracker</h1>
        <div class="chips" id="summary"></div>
    </header>

    <main>
        <div class="card">
            <div class="controls">
                <div>
                    <label for="surfaceFilter">Filter by Surface</label>
                    <select id="surfaceFilter">
                        <option value="all">All surfaces</option>
                    </select>
                </div>

                <div>
                    <label for="statusFilter">Status</label>
                    <select id="statusFilter">
                        <option value="all">Any</option>
                        <option value="ga">GA only</option>
                        <option value="preview">Preview only</option>
                    </select>
                </div>

                <div>
                    <label for="skuFilter">SKU</label>
                    <select id="skuFilter">
                        <option value="all">Any</option>
                        <option>Free</option>
                        <option>Pro</option>
                        <option>Pro+</option>
                        <option>Business</option>
                        <option>Enterprise</option>
                    </select>
                </div>

                <div>
                    <label for="versionSurface">Version Fit: choose a surface</label>
                    <select id="versionSurface">
                        <option value="">—</option>
                        <option>VS Code</option>
                        <option>Visual Studio 2022</option>
                        <option>JetBrains IDEs</option>
                        <option>Neovim</option>
                        <option>GitHub.com</option>
                        <option>CLI</option>
                        <option>Eclipse</option>
                        <option>Xcode</option>
                    </select>
                </div>

                <div>
                    <label for="versionInput">Version (e.g., 17.14 for Visual Studio, 1.102 for VS Code)</label>
                    <input id="versionInput" placeholder="e.g., 17.14 or 1.102" />
                </div>
            </div>
        </div>

        <div class="card">
            <table id="matrix">
                <thead>
                    <tr>
                        <th style="min-width: 300px;">Feature</th>
                        <th>Category</th>
                        <th>Surface</th>
                        <th>Preview Version</th>
                        <th>GA Version</th>
                        <th>Min Plugin</th>
                    </tr>
                </thead>
                <tbody id="matrixBody"></tbody>
            </table>

            <!-- Tiny inline legend -->
            <div class="legend">
                <span class="legend-item"><span class="pill pill-preview">1.2.3</span> Preview version inferred from
                    milestone date when missing. If still unknown but confirmed available, shows <span
                        class="pill pill-preview">True</span>.</span>
                <span class="legend-item"><span class="pill pill-ga">1.2.3</span> GA version inferred from milestone
                    date when missing. If still unknown but confirmed available, shows <span
                        class="pill pill-ga">True</span>.</span>
                <span class="legend-item"><span class="chevron chevron-indicator" title="Milestones drawer"></span>
                    Click the chevron to view all milestones (status, channel, versions, dates, sources) plus
                    SKUs.</span>
            </div>

            <div class="footer">
                Notes:
                <ul>
                    <li>Preview/GA columns use min_ide_version when provided, otherwise they infer the IDE version from
                        your lookup tables by milestone date (±7 days). If no version can be inferred, a colored “True”
                        appears (yellow = preview, green = GA).</li>
                    <li>“Min Plugin” (VS Code) is inferred from Copilot Chat releases near the milestone date when not
                        specified.</li>
                    <li>When “Version Fit” is set, results hide other surfaces and filter rows using the explicit or
                        inferred IDE version.</li>
                </ul>
            </div>
        </div>
    </main>

    <script>
        (async function () {
            // 1) Load core feature index and per-feature JSON
            const index = await (await fetch('data/index.json', { cache: 'no-store' })).json();
            const features = await Promise.all(index.features.map(async f => {
                const data = await (await fetch('data/' + f.path, { cache: 'no-store' })).json();
                return { slug: f.slug, path: f.path, ...data };
            }));

            // 2) Load Copilot Chat version lookup (for Min Plugin inference on VS Code)
            let chatLookup = null;
            try {
                chatLookup = await (await fetch('data/lookups/copilot-chat-versions.json', { cache: 'no-store' })).json();
            } catch (e) {
                console.warn('Copilot Chat lookup not found. Min Plugin hydration will be skipped.');
            }
            const chatVersions = (chatLookup && chatLookup.versions ? chatLookup.versions : [])
                .map(v => ({ ...v, ts: v.released_at ? Date.parse(v.released_at) : NaN }))
                .filter(v => !Number.isNaN(v.ts))
                .sort((a, b) => a.ts - b.ts);

            // 3) Load IDE version lookup tables (for IDE version inference from dates)
            // Map surface -> lookup file path
            const surfaceLookupMap = {
                'VS Code': 'data/lookups/vscode-versions.json',
                'Visual Studio 2022': 'data/lookups/visualstudio-versions.json',
                'JetBrains IDEs': 'data/lookups/jetbrains-platform-versions.json',
                'Eclipse': 'data/lookups/eclipse-versions.json',
                'Xcode': 'data/lookups/xcode-versions.json'
                // Neovim, GitHub.com, CLI typically not needed for IDE version mapping
            };

            const ideLookups = {};
            await Promise.all(Object.entries(surfaceLookupMap).map(async ([surfaceName, path]) => {
                try {
                    const j = await (await fetch(path, { cache: 'no-store' })).json();
                    const list = (j && j.versions) ? j.versions : [];
                    ideLookups[surfaceName] = list
                        .map(v => ({ ...v, ts: v.released_at ? Date.parse(v.released_at) : NaN }))
                        .filter(v => !Number.isNaN(v.ts))
                        .sort((a, b) => a.ts - b.ts);
                } catch (e) {
                    console.warn(`IDE lookup missing or invalid for ${surfaceName}: ${path}`);
                    ideLookups[surfaceName] = [];
                }
            }));

            // DOM elements
            const surfaces = index.surfaces || [];
            const surfaceFilter = document.getElementById('surfaceFilter');
            const statusFilter = document.getElementById('statusFilter');
            const skuFilter = document.getElementById('skuFilter');
            const versionSurface = document.getElementById('versionSurface');
            const versionInput = document.getElementById('versionInput');
            const matrixBody = document.getElementById('matrixBody');
            const summary = document.getElementById('summary');

            // Populate surface dropdown
            surfaces.forEach(s => {
                const opt = document.createElement('option');
                opt.textContent = s; opt.value = s;
                surfaceFilter.appendChild(opt);
            });

            // Helpers
            function cmpVersion(a, b) {
                if (!a || !b) return 0;
                const pa = a.toString().split('.').map(x => parseInt(x, 10));
                const pb = b.toString().split('.').map(x => parseInt(x, 10));
                const len = Math.max(pa.length, pb.length);
                for (let i = 0; i < len; i++) {
                    const ai = Number.isNaN(pa[i]) ? 0 : pa[i];
                    const bi = Number.isNaN(pb[i]) ? 0 : pb[i];
                    if (ai < bi) return -1;
                    if (ai > bi) return 1;
                }
                return 0;
            }

            function pickEvidence(from) {
                const ev = (from || []).slice(0, 3);
                return ev;
            }

            // Lockstep-based plugin version picker for VS Code (Copilot Chat lookup)
            function pickChatPluginVersion(dateStr, windowDays = 7) {
                if (!dateStr || chatVersions.length === 0) return null;
                const ms = Date.parse(dateStr);
                if (Number.isNaN(ms)) return null;
                const window = windowDays * 24 * 60 * 60 * 1000;
                const upper = ms + window;
                const candidates = chatVersions.filter(v => v.ts <= upper);
                if (candidates.length === 0) return null;
                const best = candidates[candidates.length - 1];
                return best.version || best.tag || null;
            }

            // IDE version inference from date using lookup tables (per surface)
            function pickIdeVersionByDate(surfaceName, dateStr, toleranceDays = 7) {
                if (!surfaceName || !dateStr) return null;
                const lookup = ideLookups[surfaceName] || [];
                if (lookup.length === 0) return null;
                const ms = Date.parse(dateStr);
                if (Number.isNaN(ms)) return null;
                const tolms = toleranceDays * 24 * 60 * 60 * 1000;
                const upper = ms + tolms;

                // Choose the latest version with release date <= (milestone date + tolerance)
                const candidates = lookup.filter(v => typeof v.ts === 'number' && v.ts <= upper);
                if (candidates.length === 0) return null;
                const best = candidates[candidates.length - 1];
                return best.version || null;
            }

            // Find earliest version (Preview or GA) for a surface, preferring explicit min_ide_version
            function earliestVersion(milestones, predicate, surfaceName) {
                const filtered = (milestones || []).filter(predicate);
                if (filtered.length === 0) return { exists: false, version: null, evidence: [], milestone: null };

                // Prefer explicit min_ide_version if present
                const withIde = filtered.filter(m => m.min_ide_version);
                if (withIde.length > 0) {
                    withIde.sort((a, b) => cmpVersion(a.min_ide_version, b.min_ide_version));
                    const chosen = withIde[0];
                    return { exists: true, version: chosen.min_ide_version, evidence: pickEvidence(chosen.evidence || []), milestone: chosen };
                }

                // Otherwise infer from lookup tables by milestone date
                const inferred = filtered
                    .map(m => ({ v: pickIdeVersionByDate(surfaceName, m.start_date), m }))
                    .filter(x => !!x.v);

                if (inferred.length > 0) {
                    inferred.sort((a, b) => cmpVersion(a.v, b.v));
                    const chosen = inferred[0];
                    return { exists: true, version: chosen.v, evidence: pickEvidence(chosen.m.evidence || []), milestone: chosen.m };
                }

                // Status exists but version cannot be determined -> True
                const chosen = filtered[0];
                return { exists: true, version: null, evidence: pickEvidence(chosen.evidence || []), milestone: chosen };
            }

            function rowMatchesFilters(feature, surfaceEntry) {
                const sf = surfaceFilter.value;
                const st = statusFilter.value;
                const sku = skuFilter.value;

                // If Version Fit surface selected, restrict to that surface
                if (versionSurface.value && surfaceEntry.surface !== versionSurface.value) return false;

                if (sf !== 'all' && surfaceEntry.surface !== sf) return false;

                if (sku !== 'all') {
                    const hasSku = feature.skus && feature.skus.some(s => s.name === sku && s.support !== 'not_included');
                    if (!hasSku) return false;
                }

                const milestones = surfaceEntry.milestones || [];
                const hasPreview = milestones.some(m => String(m.status).includes('preview'));
                const hasGA = milestones.some(m => m.status === 'ga');

                if (st === 'ga' && !hasGA) return false;
                if (st === 'preview' && !hasPreview) return false;

                // Version fit check: use explicit or inferred IDE version
                const userSurface = versionSurface.value;
                const userVersion = versionInput.value.trim();

                if (userSurface && userVersion && userSurface === surfaceEntry.surface) {
                    const relevant = milestones.filter(m => {
                        if (st === 'ga') return m.status === 'ga';
                        if (st === 'preview') return String(m.status).includes('preview');
                        return true;
                    });

                    const anyOk = relevant.some(m => {
                        const inferred = m.min_ide_version || pickIdeVersionByDate(surfaceEntry.surface, m.start_date);
                        if (inferred) return cmpVersion(inferred, userVersion) <= 0;
                        // Unknown IDE min → do not exclude
                        return true;
                    });

                    if (!anyOk) return false;
                }
                return true;
            }

            function formatDate(d) {
                if (!d) return '—';
                const dt = new Date(d);
                if (Number.isNaN(dt.getTime())) return d;
                return dt.toISOString().slice(0, 10);
            }

            function milestoneListHTML(milestones) {
                if (!milestones || milestones.length === 0) {
                    return '<div class="empty">No milestones recorded.</div>';
                }
                const order = { ga: 3, public_preview: 2, private_preview: 1, available: 2, planned: 0, deprecated: -1, withdrawn: -2 };
                const sorted = [...milestones].sort((a, b) => {
                    const da = a.start_date ? new Date(a.start_date).getTime() : 0;
                    const db = b.start_date ? new Date(b.start_date).getTime() : 0;
                    if (da !== db) return da - db;
                    return (order[b.status] ?? 0) - (order[a.status] ?? 0);
                });

                const statusBadge = (s) => {
                    const cls = s === 'ga' ? 'badge-ga'
                        : String(s).includes('preview') ? 'badge-preview'
                            : s === 'deprecated' ? 'badge-deprecated'
                                : s === 'withdrawn' ? 'badge-withdrawn'
                                    : 'badge-neutral';
                    return `<span class="badge ${cls}">${s}</span>`;
                };

                return `
      <ul class="milestone-list">
        ${sorted.map(m => `
          <li class="milestone-item">
            <div class="milestone-head">
              ${statusBadge(m.status)}
              ${m.channel ? `<span class="chip micro">${m.channel}</span>` : ''}
              <span class="muted">since</span> <strong>${formatDate(m.start_date)}</strong>
            </div>
            <div class="milestone-body">
              <div class="kv"><span class="key">Min IDE</span><span class="val">${m.min_ide_version || '—'}</span></div>
              <div class="kv"><span class="key">Min Plugin</span><span class="val">${m.min_plugin_version || '—'}</span></div>
              ${m.evidence && m.evidence.length ? `
                <div class="kv"><span class="key">Evidence</span>
                  <span class="val evidence-links">
                    ${m.evidence.slice(0, 5).map(ev => `<a href="${ev.url}" target="_blank" rel="noopener">source</a>`).join(' ')}
                  </span>
                </div>` : ''
                    }
            </div>
          </li>
        `).join('')}
      </ul>
    `;
            }

            function render() {
                matrixBody.innerHTML = '';
                let rows = 0;

                for (const f of features) {
                    // SKU chips (in drawer)
                    const skuChips = (f.skus && f.skus.length)
                        ? f.skus.map(x => `<span class="chip micro">${x.name}: ${x.support}</span>`).join(' ')
                        : '<span class="muted">No SKU data</span>';

                    for (const s of (f.surfaces || [])) {
                        if (!rowMatchesFilters(f, s)) continue;

                        const ms = s.milestones || [];

                        // Compute earliest preview and GA IDE versions with inference
                        const previewInfo = earliestVersion(ms, m => String(m.status).includes('preview'), s.surface);
                        const gaInfo = earliestVersion(ms, m => m.status === 'ga', s.surface);

                        if (statusFilter.value === 'ga' && !gaInfo.exists) continue;
                        if (statusFilter.value === 'preview' && !previewInfo.exists) continue;

                        // Determine "Min Plugin" (VS Code only), preferring explicit, else inference by date via Copilot Chat lookup
                        let minPlugin = '—';
                        const gaWithPlugin = ms.find(m => m.status === 'ga' && m.min_plugin_version);
                        const previewWithPlugin = ms.find(m => String(m.status).includes('preview') && m.min_plugin_version);
                        if (gaWithPlugin) {
                            minPlugin = gaWithPlugin.min_plugin_version;
                        } else if (previewWithPlugin) {
                            minPlugin = previewWithPlugin.min_plugin_version;
                        } else if (s.surface === 'VS Code') {
                            const refDate = (gaInfo.exists && gaInfo.milestone && gaInfo.milestone.start_date)
                                ? gaInfo.milestone.start_date
                                : (previewInfo.exists && previewInfo.milestone && previewInfo.milestone.start_date)
                                    ? previewInfo.milestone.start_date
                                    : null;
                            const inferred = pickChatPluginVersion(refDate);
                            if (inferred) minPlugin = inferred;
                        }

                        const rowId = `${f.slug}__${(s.surface || '').replace(/\s+/g, '_')}`;

                        // Main data row
                        const tr = document.createElement('tr');
                        tr.className = 'data-row';
                        tr.dataset.rowId = rowId;

                        const tdFeature = document.createElement('td');
                        tdFeature.innerHTML = `
          <div class="feature-cell">
            <button class="chevron" aria-expanded="false" aria-controls="drawer-${rowId}" title="Show all milestones"></button>
            <strong>${f.feature}</strong>
          </div>`;
                        tr.appendChild(tdFeature);

                        const tdCat = document.createElement('td');
                        tdCat.textContent = f.category || '';
                        tr.appendChild(tdCat);

                        const tdSurface = document.createElement('td');
                        tdSurface.textContent = s.surface;
                        tr.appendChild(tdSurface);

                        const tdPreview = document.createElement('td');
                        if (previewInfo.exists) {
                            const label = previewInfo.version ? previewInfo.version : 'True';
                            const link = (previewInfo.evidence && previewInfo.evidence[0] && previewInfo.evidence[0].url) ? previewInfo.evidence[0].url : null;
                            if (link) {
                                tdPreview.innerHTML = `<a class="pill pill-preview pill-link" href="${link}" target="_blank" rel="noopener">${label}</a>`;
                            } else {
                                tdPreview.innerHTML = `<span class="pill pill-preview">${label}</span>`;
                            }
                        } else {
                            tdPreview.textContent = '—';
                        }
                        tr.appendChild(tdPreview);

                        const tdGA = document.createElement('td');
                        if (gaInfo.exists) {
                            const label = gaInfo.version ? gaInfo.version : 'True';
                            const link = (gaInfo.evidence && gaInfo.evidence[0] && gaInfo.evidence[0].url) ? gaInfo.evidence[0].url : null;
                            if (link) {
                                tdGA.innerHTML = `<a class="pill pill-ga pill-link" href="${link}" target="_blank" rel="noopener">${label}</a>`;
                            } else {
                                tdGA.innerHTML = `<span class="pill pill-ga">${label}</span>`;
                            }
                        } else {
                            tdGA.textContent = '—';
                        }
                        tr.appendChild(tdGA);

                        const tdMinPlugin = document.createElement('td');
                        tdMinPlugin.textContent = minPlugin || '—';
                        tr.appendChild(tdMinPlugin);

                        // Drawer row (milestones + SKUs)
                        const trDrawer = document.createElement('tr');
                        trDrawer.className = 'drawer-row';
                        trDrawer.id = `drawer-${rowId}`;
                        const tdDrawer = document.createElement('td');
                        tdDrawer.colSpan = 6;
                        tdDrawer.innerHTML = `
          <div class="drawer">
            <div class="drawer-title">
              All milestones for <strong>${f.feature}</strong> on <strong>${s.surface}</strong>
            </div>
            <div class="drawer-skus">
              <span class="key">Available SKUs</span>
              <span class="val">${skuChips}</span>
            </div>
            ${milestoneListHTML(ms)}
            <div class="muted" style="margin-top:8px;">
              Tip: IDE versions shown above use explicit minimums when present, otherwise they’re inferred from date lookups (±7 days).
            </div>
          </div>`;
                        trDrawer.appendChild(tdDrawer);

                        matrixBody.appendChild(tr);
                        matrixBody.appendChild(trDrawer);
                        rows++;
                    }
                }

                // Wire up row chevrons
                matrixBody.querySelectorAll('.chevron').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const dataRow = btn.closest('tr.data-row');
                        const rowId = dataRow?.dataset.rowId;
                        if (!rowId) return;
                        const drawer = document.getElementById(`drawer-${rowId}`);
                        const isOpen = drawer?.classList.toggle('open');
                        if (isOpen) btn.classList.add('open'); else btn.classList.remove('open');
                        btn.setAttribute('aria-expanded', String(!!isOpen));
                    });
                });

                // Summary chips
                summary.innerHTML = [
                    `<span class="chip">Features loaded: ${features.length}</span>`,
                    `<span class="chip">Rows: ${rows}</span>`,
                    `<span class="chip">Surface: ${surfaceFilter.value}</span>`,
                    `<span class="chip">Status: ${statusFilter.value}</span>`,
                    `<span class="chip">SKU: ${skuFilter.value}</span>`,
                    versionSurface.value ? `<span class="chip">Version fit: ${versionSurface.value} ≤ ${versionInput.value || 'n/a'}</span>` : ''
                ].filter(Boolean).join('');
            }

            [surfaceFilter, statusFilter, skuFilter, versionSurface, versionInput]
                .forEach(el => el.addEventListener('input', render));

            render();
        })();
    </script>
</body>

</html>